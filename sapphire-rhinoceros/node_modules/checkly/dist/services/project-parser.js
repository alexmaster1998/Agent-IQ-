"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseProject = void 0;
const constructs_1 = require("../constructs");
const util_1 = require("util");
const glob = require("glob");
const util_2 = require("./util");
const path = require("path");
const globPromise = (0, util_1.promisify)(glob);
const BASE_CHECK_DEFAULTS = {
    runtimeId: '2023.02',
};
async function parseProject(opts) {
    const { directory, checkMatch = '**/*.check.{js,ts}', browserCheckMatch, projectLogicalId, projectName, repoUrl, ignoreDirectoriesMatch = [], checkDefaults = {}, browserCheckDefaults = {}, availableRuntimes, checklyConfigConstructs, } = opts;
    const project = new constructs_1.Project(projectLogicalId, {
        name: projectName,
        repoUrl,
    });
    checklyConfigConstructs === null || checklyConfigConstructs === void 0 ? void 0 : checklyConfigConstructs.forEach((construct) => project.addResource(construct.type, construct.logicalId, construct));
    constructs_1.Session.project = project;
    constructs_1.Session.basePath = directory;
    constructs_1.Session.checkDefaults = Object.assign({}, BASE_CHECK_DEFAULTS, checkDefaults);
    constructs_1.Session.browserCheckDefaults = browserCheckDefaults;
    constructs_1.Session.availableRuntimes = availableRuntimes;
    // TODO: Do we really need all of the ** globs, or could we just put node_modules?
    const ignoreDirectories = ['**/node_modules/**', '**/.git/**', ...ignoreDirectoriesMatch];
    await loadAllCheckFiles(directory, checkMatch, ignoreDirectories);
    await loadAllBrowserChecks(directory, browserCheckMatch, ignoreDirectories, project);
    return project;
}
exports.parseProject = parseProject;
async function loadAllCheckFiles(directory, checkFilePattern, ignorePattern) {
    const checkFiles = await findFilesWithPattern(directory, checkFilePattern, ignorePattern);
    for (const checkFile of checkFiles) {
        // setting the checkFilePath is used for filtering by file name on the command line
        constructs_1.Session.checkFileAbsolutePath = checkFile;
        constructs_1.Session.checkFilePath = (0, util_2.pathToPosix)(path.relative(directory, checkFile));
        if (checkFile.endsWith('.js')) {
            await (0, util_2.loadJsFile)(checkFile);
        }
        else if (checkFile.endsWith('.ts')) {
            await (0, util_2.loadTsFile)(checkFile);
        }
        else {
            throw new Error('Unable to load check configuration file with unsupported extension. ' +
                `Please use a .js or .ts file instead.\n${checkFile}`);
        }
        constructs_1.Session.checkFilePath = undefined;
        constructs_1.Session.checkFileAbsolutePath = undefined;
    }
}
async function loadAllBrowserChecks(directory, browserCheckFilePattern, ignorePattern, project) {
    if (!browserCheckFilePattern) {
        return;
    }
    const checkFiles = await findFilesWithPattern(directory, browserCheckFilePattern, ignorePattern);
    const preexistingCheckFiles = new Set();
    Object.values(project.data.check).forEach((check) => {
        if (check instanceof constructs_1.BrowserCheck && check.scriptPath) {
            preexistingCheckFiles.add(check.scriptPath);
        }
    });
    for (const checkFile of checkFiles) {
        const relPath = (0, util_2.pathToPosix)(path.relative(directory, checkFile));
        // Don't create an additional check if the checkFile was already added to a check in loadAllCheckFiles.
        if (preexistingCheckFiles.has(relPath)) {
            continue;
        }
        const browserCheck = new constructs_1.BrowserCheck((0, util_2.pathToPosix)(relPath), {
            name: path.basename(checkFile),
            code: {
                entrypoint: checkFile,
            },
        });
    }
}
async function findFilesWithPattern(directory, pattern, ignorePattern) {
    // The files are sorted to make sure that the processing order is deterministic.
    const files = await globPromise(pattern, {
        nodir: true,
        cwd: directory,
        ignore: ignorePattern,
        absolute: true,
    });
    return files.sort();
}
//# sourceMappingURL=project-parser.js.map